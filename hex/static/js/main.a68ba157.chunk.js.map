{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["max_rating","board_size","sess","InferenceSession","url","sess_init","info","agent_is_blue","load_model","a","loadModel","PosToId","x","y","IdToPos","id","FullNeighbors","_","range","neighbors","push","Neighbors","HasWinner","board","starts","targets","p","target","toVisit","visited","Set","length","node","pop","neighbor","toString","has","add","Toggle","props","state","showRatings","initial","handleClick","bind","this","toggle","setState","onClick","React","Component","HexGame","setup","cells","Array","fill","connected_sets","connected_set_rows","winner","model_output","model_display","moves","clickCell","G","ctx","reduce","cur_player","currentPlayer","has_won","last_move","endIf","turn","moveLimit","ai","enumerate","i","move","args","minimax","depth","current_player","first_player","other_player","value","best","AddBorder","input_values","border_color","includes","HexBoard","setDisplayRatings","display_ratings","player","isActive","agent","ai_board","from","sure_win_move","findSureWinMove","runModel","then","result","num_moves","Math","pow","toFixed","test_board","sure_win","console","log","input_array","input","Tensor","Float32Array","run","output","values","next","data","input_values2","evalModel","outputTensor","outputTensor2","average_output","final_output","error","gameover","p1Style","stroke","strokeWidth","p2Style","emptyStyle","hexagons","q","r","key","cellStyle","s","cellText","b","class","href","className","width","height","viewBox","size","flat","spacing","App","Client","game","debug","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.a68ba157.chunk.js","sourcesContent":["// TODO\n// * monte carlo move selection\n\nimport {Client} from \"boardgame.io/react\";\nimport {Hexagon, HexGrid, Layout, Text} from \"react-hexgrid\";\nimport React from \"react\";\nimport {InferenceSession, Tensor} from \"onnxjs\";\nimport _ from \"lodash\";\n\nimport \"./App.css\";\n\nconst board_size = 11;\nconst sess = new InferenceSession();\nconst url = \"./11_2w4_2000.onnx\";\n\nlet sess_init = false;\nlet info = \"\";\nlet agent_is_blue = true;\nlet max_rating;\n\n\nasync function load_model() {\n  await sess.loadModel(url);\n  sess_init = true;\n}\n\nfunction PosToId(x, y) {\n  return x + board_size * y;\n}\n\nfunction IdToPos(id) {\n  const x = id % board_size;\n  const y = (id - x) / board_size;\n  return [x, y];\n}\n\nfunction Neighbors(id) {\n  const [x, y] = IdToPos(id);\n\n  let neighbors = [];\n  if (x !== 0) {\n    neighbors.push(PosToId(x - 1, y));\n  }\n  if (x !== 0 && y !== board_size - 1) {\n    neighbors.push(PosToId(x - 1, y + 1));\n  }\n  if (y !== 0) {\n    neighbors.push(PosToId(x, y - 1));\n  }\n  if (y !== board_size - 1) {\n    neighbors.push(PosToId(x, y + 1));\n  }\n  if (x !== board_size - 1 && y !== 0) {\n    neighbors.push(PosToId(x + 1, y - 1));\n  }\n  if (x !== board_size - 1) {\n    neighbors.push(PosToId(x + 1, y));\n  }\n\n  return neighbors;\n}\n\nfunction FullNeighbors(id) {\n  if (id === 'red-bottom') {\n    return _.range(board_size * (board_size - 1), board_size * board_size);\n  }\n  if (id === 'red-top') {\n    return _.range(0, board_size);\n  }\n  if (id === 'blue-left') {\n    return _.range(0, board_size * board_size, board_size);\n  }\n  if (id === 'blue-right') {\n    return _.range(board_size - 1, board_size * board_size, board_size);\n  }\n  let neighbors = Neighbors(id);\n  const [x, y] = IdToPos(id);\n  if (x === 0) {\n    neighbors.push('blue-left');\n  }\n  if (x === board_size - 1) {\n    neighbors.push('blue-right');\n  }\n  if (y === 0) {\n    neighbors.push('red-top');\n  }\n  if (y === board_size - 1) {\n    neighbors.push('red-bottom');\n  }\n  return neighbors;\n}\n\n/**\n * @return {boolean}\n */\nfunction HasWinner(board) {\n  const starts = ['red-top', 'blue-left'];\n  const targets = ['red-bottom', 'blue-right'];\n  for (let p in _.range(2)) {\n    const target = targets[p];\n    let toVisit = [starts[p]];\n    let visited = new Set();\n    while (toVisit.length > 0) {\n      const node = toVisit.pop();\n      for (const neighbor of FullNeighbors(node)) {\n        if (neighbor === target) {\n          return true;\n        }\n        if (typeof neighbor === 'string') {\n          continue;\n        }\n        if (board[neighbor] === p.toString() && !visited.has(neighbor)) {\n          toVisit.push(neighbor);\n          visited.add(neighbor);\n        }\n      }\n    }\n  }\n  return false;\n}\n\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {showRatings: props.initial};\n\n    // This binding is necessary to make `this` work in the callback\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.props.toggle(!this.state.showRatings);\n    this.setState((state) => ({\n      showRatings: !state.showRatings,\n    }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.showRatings ? \"Hide Ratings\" : \"Show Ratings\"}\n      </button>\n    );\n  }\n}\n\nconst HexGame = {\n  setup: () => ({\n    cells: Array(board_size * board_size).fill(null),\n    connected_sets: [[], []],\n    connected_set_rows: [[], []],\n    winner: null,\n    model_output: Array(board_size * board_size).fill(null),\n    model_display: Array(board_size * board_size).fill(\"\"),\n    // index 0 will always be red independent of swap\n    // save a pair of sets for each player:\n    //   * the first set is a connected component of stones\n    //   * the second set is the indices of these stones in the direction\n    //     of the player thus the winning condition is having\n    //     0 and (size-1) in one of the second sets.\n  }),\n\n  moves: {\n    clickCell: (G, ctx, id) => {\n      const num_moves = G.cells.reduce((x, y) => x + (y ? 1 : 0), 0);\n      if (num_moves == 1 && G.cells[id] == \"0\") {\n        // switch!\n        agent_is_blue = !agent_is_blue;\n        info = \"Switched!\";\n      } else {\n        let cur_player = ctx.currentPlayer;\n        if (!agent_is_blue) {\n          cur_player = ctx.currentPlayer === \"0\" ? \"1\" : \"0\";\n        }\n        G.cells[id] = cur_player;\n        const has_won = HasWinner(G.cells);\n        G.last_move = id;\n        if (has_won) {\n          G.winner = cur_player;\n        }\n      }\n    },\n  },\n\n  endIf: (G, ctx) => {\n    if (G.winner !== null) {\n      return {winner: G.winner};\n    }\n  },\n\n  turn: {\n    moveLimit: 1,\n  },\n\n  ai: {\n    enumerate: (G, ctx) => {\n      let moves = [];\n      for (let i = 0; i < board_size * board_size; i++) {\n        if (G.cells[i] === null) {\n          moves.push({move: \"clickCell\", args: [i]});\n        }\n      }\n      return moves;\n    },\n  },\n};\n\n// rating: +1 = red (\"0\") wins\n//         -1 = blue (\"1\") wins\n// might return 0 although the opponent could force a win.\nfunction minimax(board, depth, current_player, first_player) {\n  const other_player = current_player === \"0\" ? \"1\" : \"0\";\n  if (HasWinner(board)) {\n    // other player won.\n    if (current_player === \"0\") {\n      return [-1, null]; // blue won\n    } else {\n      return [1, null]; // red won\n    }\n  }\n\n  if (depth === 0) {\n    return [0, null]; // no one won\n  }\n  if (current_player === \"0\") { // red, maximizing\n    let value = -10;\n    let best = null;\n    for (let i = 0; i < board_size * board_size; i++) {\n      if (board[i] !== null) {\n        continue;\n      }\n      board[i] = current_player;\n      const a = minimax(board, depth - 1, other_player, first_player);\n      board[i] = null;\n      if (a[0] > value) {\n        value = a[0];\n        best = i;\n      }\n      if (value >= 1) {\n        // this is good enough\n        return [value, best];\n      }\n      if (current_player !== first_player && value === 0) {\n        // this is good enough for the second player.\n        return [value, best];\n      }\n    }\n    return [value, best];\n  } else { // blue, minimizing\n    let value = 10;\n    let best = null;\n    for (let i = 0; i < board_size * board_size; i++) {\n      if (board[i] !== null) {\n        continue;\n      }\n      board[i] = current_player;\n      const a = minimax(board, depth - 1, other_player, first_player);\n      board[i] = null;\n      if (a[0] < value) {\n        value = a[0];\n        best = i;\n        if (value <= -1) {\n          // this is bad enough\n          return [value, best];\n        }\n        if (current_player !== first_player && value === 0) {\n          // this is good enough for the second player.\n          return [value, best];\n        }\n      }\n    }\n    return [value, best];\n  }\n}\n\nfunction AddBorder(x, y, input_values, border_color) {\n  if ([-1, board_size].includes(x) && [-1, board_size].includes(y)) {\n    // on both players borders\n    input_values.push(0);\n    return true;\n  }\n  if (!([-1, board_size].includes(x) || [-1, board_size].includes(y))) {\n    // no border\n    return false;\n  }\n  if ([-1, board_size].includes(x)) {\n    input_values.push(border_color ? 1 : 0);\n  } else {\n    input_values.push(border_color ? 0 : 1);\n  }\n  return true;\n}\n\nclass HexBoard extends React.Component {\n  constructor(props) {\n    super(props);\n    this.setDisplayRatings = this.setDisplayRatings.bind(this);\n    this.state = {display_ratings: false};\n  }\n\n  findSureWinMove(board, player) {\n    for (let depth of [1, 3]) {\n      const a = minimax(board, depth, player, player);\n      if (player === '0') {\n        if (a[0] > 0) {\n          return a[1];\n        }\n      } else {\n        if (a[0] < 0) {\n          return a[1];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  onClick(id) {\n    if (!this.isActive(id)) {\n      return;\n    }\n    // build board for ai independently from\n    // game mechanics to avoid race conditions.\n    const player = agent_is_blue ? \"0\" : \"1\";\n    const agent = agent_is_blue ? \"1\" : \"0\";\n    let ai_board = Array.from(this.props.G.cells);\n    ai_board[id] = player;\n\n    // actually make the move\n    this.props.moves.clickCell(id);\n\n    if (HasWinner(ai_board)) {\n      // player has already won.\n      return;\n    }\n\n    const sure_win_move = this.findSureWinMove(ai_board, agent);\n    if (sure_win_move !== null) {\n      console.log(\"Found sure win move\", sure_win_move);\n      this.props.moves.clickCell(sure_win_move);\n      for (let i = 0; i < board_size * board_size; i++) {\n        this.props.G.model_display[i] = \"\";\n      }\n      return;\n    }\n\n    this.runModel(ai_board).then((result) => {\n      // AI move selection\n      const num_moves = this.props.G.cells.reduce((x, y) => x + (y ? 1 : 0), 0);\n      let best = -1;\n      for (let i = 0; i < board_size * board_size; i++) {\n        if (num_moves <= 1 || this.props.G.cells[i] === null) {\n          if (best === -1 || result[i] > max_rating) {\n            best = i;\n            max_rating = result[i];\n          }\n        }\n      }\n      let score_sum = 0;\n      for (let i = 0; i < board_size * board_size; i++) {\n        if (num_moves <= 1 || this.props.G.cells[i] === null) {\n          const score = Math.pow(2, result[i] - max_rating);\n          score_sum += score;\n        }\n      }\n\n      for (let i = 0; i < board_size * board_size; i++) {\n        if (num_moves <= 1 || this.props.G.cells[i] === null) {\n          const score = Math.pow(2, result[i] - max_rating);\n          //this.props.G.model_display[i] = (100 * score / score_sum).toFixed(0);\n          this.props.G.model_display[i] = result[i].toFixed(1);\n        } else {\n          this.props.G.model_display[i] = \"\";\n        }\n      }\n\n      let test_board = Array.from(this.props.G.cells);\n      test_board[id] = player;\n      test_board[best] = agent;\n      const sure_win = this.findSureWinMove(test_board, player);\n      if (sure_win !== null) {\n        console.log(\"Player can surely win with the suggested move\", best, \"Moving to the sure win move instead.\");\n        best = sure_win;\n      }\n\n      this.props.moves.clickCell(best);\n    });\n  }\n\n  setDisplayRatings(display_ratings) {\n    this.setState({display_ratings: display_ratings});\n  }\n\n  async evalModel(input_array) {\n    const input = [\n      new Tensor(new Float32Array(input_array), \"float32\", [1, 2, board_size + 2, board_size + 2]),\n    ];\n    const output = await sess.run(input);\n    return output.values().next().value.data;\n  }\n\n  async runModel(cells) {\n    try {\n      info = \"waiting for agent to move...\";\n      if (!sess_init) {\n        await load_model();\n      }\n\n      let input_values = [];\n      if (agent_is_blue) {\n        for (let x = -1; x < board_size + 1; x++) {\n          for (let y = -1; y < board_size + 1; y++) {\n            if (!AddBorder(x, y, input_values, 1)) {\n              const id = PosToId(x, y);\n              input_values.push(cells[id] === \"1\" ? 1 : 0);\n            }\n          }\n        }\n        for (let x = -1; x < board_size + 1; x++) {\n          for (let y = -1; y < board_size + 1; y++) {\n            if (!AddBorder(x, y, input_values, 0)) {\n              const id = PosToId(x, y);\n              input_values.push(cells[id] === \"0\" ? 1 : 0);\n            }\n          }\n        }\n      } else {\n        for (let y = -1; y < board_size + 1; y++) {\n          for (let x = -1; x < board_size + 1; x++) {\n            if (!AddBorder(x, y, input_values, 0)) {\n              const id = PosToId(x, y);\n              input_values.push(cells[id] === \"0\" ? 1 : 0);\n            }\n          }\n        }\n        for (let y = -1; y < board_size + 1; y++) {\n          for (let x = -1; x < board_size + 1; x++) {\n            if (!AddBorder(x, y, input_values, 1)) {\n              const id = PosToId(x, y);\n              input_values.push(cells[id] === \"1\" ? 1 : 0);\n            }\n          }\n        }\n      }\n      let input_values2 = [];\n      for (let id = 0; id < (board_size + 2) * (board_size + 2); id++) {\n        input_values2.push(input_values[(board_size + 2) * (board_size + 2) - id - 1]);\n      }\n      for (let id = 0; id < (board_size + 2) * (board_size + 2); id++) {\n        input_values2.push(input_values[2 * (board_size + 2) * (board_size + 2) - id - 1]);\n      }\n\n      const outputTensor = await this.evalModel(input_values);\n      const outputTensor2 = await this.evalModel(input_values2);\n      let average_output = [];\n      for (let id = 0; id < board_size * board_size; id++) {\n        average_output.push((outputTensor[id] + outputTensor2[board_size * board_size - id - 1]) / 2);\n      }\n\n      let final_output = [];\n      if (agent_is_blue) {\n        // need to transpose\n        for (let x = 0; x < board_size; x++) {\n          for (let y = 0; y < board_size; y++) {\n            const id = PosToId(x, y);\n            final_output.push(average_output[id]);\n          }\n        }\n      } else {\n        final_output = average_output;\n      }\n\n      for (let i = 0; i < board_size * board_size; i++) {\n        this.props.G.model_output[i] = final_output[i];\n      }\n\n      info = \"\";\n      return final_output;\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  cellStyle(id) {\n    if (this.props.G.cells[id] === null) {\n      return \"emptyStyle\";\n    }\n    if (this.props.G.cells[id] === \"0\") {\n      return \"p1Style\";\n    }\n    return \"p2Style\";\n  }\n\n  cellText(id, display_ratings) {\n    if (display_ratings) {\n      return this.props.G.model_display[id];\n    }\n    return \"\";\n  }\n\n  isActive(id) {\n    if (!this.props.isActive) return false;\n    if (this.props.G.cells[id] !== null) return false;\n    return true;\n  }\n\n  render() {\n    if (this.props.ctx.gameover) {\n      let player = agent_is_blue ? \"0\" : \"1\";\n      info =\n        this.props.ctx.gameover.winner === player\n          ? \"Player has won!\"\n          : \"Agent has won!\";\n    }\n\n    const p1Style = {\n      fill: \"rgb(251, 41, 67)\",\n      stroke: \"black\",\n      strokeWidth: 0.1,\n    };\n    const p2Style = {\n      fill: \"rgb(6, 154, 243)\",\n      stroke: \"black\",\n      strokeWidth: 0.1,\n    };\n    const emptyStyle = {\n      fill: \"white\",\n      stroke: \"black\",\n      strokeWidth: 0.1,\n    };\n\n    let hexagons = [];\n    // field hexagons, initially empty\n    for (let q = 0; q < board_size; q++) {\n      for (let r = 0; r < board_size; r++) {\n        const id = q + r * board_size;\n        hexagons.push(\n          <Hexagon\n            id={id}\n            key={id}\n            onClick={() => this.onClick(id)}\n            cellStyle={\n              this.cellStyle(id) === \"p2Style\"\n                ? p2Style\n                : this.cellStyle(id) === \"p1Style\"\n                ? p1Style\n                : emptyStyle\n            }\n            q={q}\n            r={r}\n            s={-q - r}\n          >\n            <Text>{this.cellText(id, this.state.display_ratings)}</Text>\n          </Hexagon>\n        );\n      }\n    }\n\n    // border hexagons\n    let id = board_size * board_size;\n    for (let a = 0; a < board_size; a++) {\n      let b = -1;\n      hexagons.push(\n        <Hexagon key={id++} cellStyle={p1Style} q={a} r={b} s={-a - b}/>\n      );\n      hexagons.push(\n        <Hexagon key={id++} cellStyle={p2Style} q={b} r={a} s={-a - b}/>\n      );\n      b = board_size;\n      hexagons.push(\n        <Hexagon key={id++} cellStyle={p1Style} q={a} r={b} s={-a - b}/>\n      );\n      hexagons.push(\n        <Hexagon key={id++} cellStyle={p2Style} q={b} r={a} s={-a - b}/>\n      );\n    }\n\n    return (\n      <div>\n        <div class=\"intro\">\n          HexHex - A reinforcement deep learning agent by Simon Buchholz, David\n          Harbecke, and Pascal Van Cleeff.\n          <br/>\n          <a href=\"https://github.com/harbecke/hex\">github.com/harbecke/hex</a>\n        </div>\n        <div id=\"winner\">{info}</div>\n        <div id=\"controls\">\n          <Toggle initial={false} toggle={this.setDisplayRatings}/>\n        </div>\n        <div className=\"App\">\n          <HexGrid width={1000} height={800} viewBox=\"0 -3 30 30\">\n            <Layout size={{x: 1, y: 1}} flat={false} spacing={1}>\n              {hexagons}\n            </Layout>\n          </HexGrid>\n        </div>\n      </div>\n    );\n  }\n}\n\nconst App = Client({game: HexGame, board: HexBoard, debug: false});\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}